---
sidebar_position: 6
---


# AtlasTexture

## 概要

テクスチャの必要な部分のみを集めたテクスチャを作ることでVRAMの削減を実現する、  
アイランド再配置技術と矩形転写(または、UVtoUV の転写技術)を基礎とした [AAO](https://github.com/anatawa12/AvatarOptimizer) に触発されて作られたコンポーネント

## 属性

- [MainComponent](/docs/Reference/General/ComponentBasicBehavior.md#maincomponent-と-subcomponent)
- [OwnedComponent](/docs/Reference/General/ComponentBasicBehavior.md#ownedcomponent-と-annotationcomponent)
- フェーズ -> [Optimizing | 最適化](/docs/Reference/General/ExecutionOrder.md#optimizing--最適化)

## Atlas化される条件

### レンダラー

- 適用時にアクティブであること、ただし [適用時に非アクティブなレンダラーを含める](#適用時に非アクティブなレンダラーを含める)が有効な場合は非アクティブでも対象となる
- tag が EditorOnly ではないこと
- Renderer の持つ Mesh が存在すること
- Renderer の持つ Mesh の UV0 が存在すること
- Renderer の持つマテリアルが1つ以上存在すること

### マテリアルが持つテクスチャー

以下のシェーダーである場合、[アトラス対象のUVチャンネル](#アトラス対象のuvチャンネル) に指定されている UV チャンネルを使用しているテクスチャがアトラス化されます。

- [lilToon](https://lilxyzw.github.io/lilToon/)
- Standard
- VRCSDK StandardLite
- VRCSDK ToonLit

それ以外のシェーダーは [ITTShaderTextureUsageInformation](/docs/Reference/AtlasTexture/ITTShaderTextureUsageInformation) でサポートが追加されていない場合、
Property "_MainTex" が UV0 を参照しているとし、[アトラス対象のUVチャンネル](#アトラス対象のuvチャンネル) が UV0 の場合にそれのみが対象になります。

## 設定項目

### マテリアルセレクター(選択済みマテリアル)

アトラス化の対象の選択ができます。

必要なマテリアルが表示されていない場合、「リフレッシュマテリアル」ボタンを使用すると治る場合があります。

### アイランド大きさ優先度(アイランド大きさ優先度調整)

アイランドの大きさ優先度を指定可能な項目で、以下の基準で優先度を割り当てることができます。

#### Set From Material

マテリアル基準でアイランドの大きさ優先度を割り当てることができます。

マテリアルのリストに直接いれる or 一覧選択のメニューで選択する ことでそのマテリアルに属する Island の大きさ優先度を割り当てることが可能になります。

#### Set From Island Selector

マテリアル基準よりも細かい単位、アイランドごとにアイランドの大きさ優先度を割り当てることができます。

[アイランドセレクター](/docs/Reference/IslandSelector) を割り当てれば、それによって選択されるアイランドに 優先度の値が割り当てられます。

### マテリアル設定

マテリアルの結合が可能になる設定です。基本的には結合時参照が None (割り当てられていない状態) ではマテリアルが結合されず、何らかのマテリアルが割り当てられている場合にそのマテリアルに結合されるようになります。

#### マテリアルの結合グループ

マテリアルを部分的に選択し、それらのマテリアル結合時の参照を指定することが可能です。

そのグループで選択されたマテリアルだけ別のマテリアルに結合したり、その部分だけ結合しない指定も可能です。

#### すべてのマテリアル結合時参照

ここにマテリアルを割り当てると、上記マテリアル結合グループによって指定されなかった(マテリアル結合グループが一つもない場合はすべて)マテリアルが割り当てたマテリアルに結合されるようになります。

すべてのマテリアルを一つにしたいときなどに割り当てることを想定しています。

### アトラス化設定

#### アトラステクスチャーサイズ

アトラス化した後のテクスチャの横幅になります。
基本的には正方形で、縦幅もこのサイズになりますが、アトラス化対象が小さいとき、2のべき乗のステップで上部分が切り取られ横長な長方形になることがあります。

#### カスタムアスペクト

アトラステクスチャーサイズの縦サイズを指定可能にできる項目です。

##### アトラステクスチャーの縦のサイズ

ここに指定したサイズまたはそれ以下に、アトラス化したテクスチャの縦幅になります。

アトラス化後のテクスチャのサイズを(ある程度アトラス化対象が大きい場合は)縦長にしたり、縦幅を縮めてアトラステクスチャーサイズを小さくしたりするためにあります。

### アトラス対象のUVチャンネル

対応しているシェーダーが UV0 以外を参照するテクスチャーが存在する場合に、それら UV0 以外を参照するテクスチャーをアトラス化対象に設定できます。

#### パディング

アイランドを再配置するときに、[アイランド](/docs/Reference/Common/Island)同士の間隔を調整する設定

#### 適用時に非アクティブなレンダラーを含める

アトラス化を適用するときに、非アクティブなGameObjectに付いているレンダラーを含めるオプション

アニメーション等でデフォルトでオフなアクセサリーが存在する場合に使用することを推奨

#### 大きさの優先度を強制

通常、場所が足りないときに大きさの優先度を加味して縮小しますが、この項目が有効な場合は場所の不足にかかわらず大きさの優先度を基に強制的に縮小します。

#### テクスチャーを強制的にセットする

アトラス化したテクスチャーをマテリアルに割り当てるとき、すでにテクスチャーが存在する場合にのみ置き換えられるのが通常動作ですが、この機能は既に存在するテクスチャーがなかったとしても強制的に設定する機能

#### 背景色

アトラス化されたテクスチャの背景色を設定でき、 MipMap や テクスチャの圧縮形式などに影響します。

#### ピクセルノーマライズ

アイランドの移動をピクセル単位でノーマライズする機能です。

アトラステクスチャーサイズがアトラス化する対象と比べて十分な大きさがあり、ダウンスケーリングが行われなかった場合に、元のテクスチャーとの見た目の劣化が抑えられます。

### テクスチャー詳細設定

テクスチャの詳細な設定を行うための項目です。 [詳細](./TextureFineTuning.md)

---
<details>
  <summary>**ReinaSakiria's-Note**</summary>

このコンポーネントは ... その原型となるものまで数えるなら TexTransTool 最初のコンポーネントであり、 v0.0.0 の頃から存在します。

その原型は AtlasSet と言う名前であったり、そもそもその頃は このツールそれ自体の名前が TexturAtlasCompiler という名前であったり ... 懐かしいいですね！

当時はテクスチャの処理というのが何もわかっておらず、他にも純粋な実力のなさによって、アトラス化を行う程度のことで 2分半以上かかっていたりすることもありました。
それでも、GPU を使えるようになったり、その GPU の更に優れた扱い、最適化が可能になって、いまはアトラス化にかかる時間は秒単位になっています。あの頃からはちょっと考えられない ... (あの頃は SimpleDecal も一つ適用するのに 5秒かかっていた時期なので本当に早くなったものですね！)

少し実装の話をしますが、 AtlasTexture は2つのロジックが核となっているのですが ... それは 「UVの再配置」 と 「UVの再配置に合わせたテクスチャ生成」。
私は前者は 2D ビンパッキング問題として、後者は 三角形の重心座標系を用いた転写を使用することで解決したのが最初の実装です。

今思うと、三角形の重心座標系を用いるのは明らかにオーバーエンジニアリングで過剰な技術だったわけなので今は矩形単位での転写が行われていますが、その技術が SimpleDecal に流用され、 TexTransTool につながるので重要な存在でも在ります。

ですが、最初に作るものとしては、 Blender で UV1 を作らせて、その UV をスワップするようなコンポーネントを実装するべきだったような気がします。最初に実装するにしてはあまりにもコストが大きい、私が無知だったゆえにその難しさがわからず、作ることためらわなかったせいで ... でも実際形になってそこからここまで実用的なものに発展した、そう思うと結果論ではあるけど、無謀ではあるけれど間違いではなかったとも思える。

元々このコンポーネントは AAO がメッシュを非破壊でマージ可能になったのを見て、扱いやすさのためにメッシュをとにかく分けていく方針が可能になったことをみて、テクスチャも私が作りやすさのためにテクスチャを衣装の一まとまりとかそんなの度返しで、衣装の一つのパーツレベルでテクスチャを割り振れるようにして、UVパズルを作るのを完全に辞め、AAO のようにビルド時にすべてをアトラス化してしまえばいいという思想を実現するために作った側面があります。

結局、とうの私はこのツールを作り始めたことが大きな原因で、アバターを作らなくなってしまったので、問題は解決したが当初の目的でその恩恵を受けれていないという ... まぁまた私のアバターは作りたいものですね。

そういえば TTT v0.10.0 にてかなり大きな方向転換が AtlasTexture にももたらしました、 TTT は v0.9.0 頃から v1.0.0 に向けての調整を行ってたのですが、 v0.9.0 のあたりが SimpleDecal の回で v0.10.0 が AtlasTexture の回なので特にです。

v1.0.0 に向けてすることとして大きく行われたのは、保証できないようなそもそも困難な機能を別のコンポーネントにできるだけ切り離すことや、機能の取扱の単純化。

WriteOriginalUV は TTT UVCopy として切り離されたり、 PropertyBake 機能に至っては削除し、 lilToon 専用で [ReinaS' lilToon NDMF Utility](https://github.com/ReinaS-64892/ReinaS-lilToonNDMFUtility) に `LNU lilToonMaterialNormalizer` として 移動したり、MergeMaterial を消して 基本的に結合時参照があれば結合するし、なければ結合しないの仕様変更、大きさ優先度は実験的機能と結合して新しい形にして、セーブデータの持ち方を単純化したり ... かなり使い勝手が変わるかもしれません。でも、これまでの TTT を使ってこれている人々はついてこれると信じています。(ついてこれるような人々をターゲットとしてこのコンポーネントは設計しています。)

それと、 TTT v1.0.0 に v0.10.0 の形でそのままゆくとので、これが最後の AtlasTexture に対する破壊になるでしょう、もし変わるとしても AtlasTexture はそのままで AtlasTextureV2 が生まれることでしょう。(ちなみに、TTT v2.0.0 は作らないよ。少なくとも **Unity** 上で動く TexTransTool は v2.0.0 にならない。)
</details>
